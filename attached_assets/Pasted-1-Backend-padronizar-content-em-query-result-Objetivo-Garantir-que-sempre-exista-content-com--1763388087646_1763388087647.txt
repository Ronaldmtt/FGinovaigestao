1. Backend â€“ padronizar content em query_result
ðŸ§  Objetivo

Garantir que sempre exista content com markdown em qualquer resposta do bot â€“ inclusive nas de type: "query_result".

Onde mudar

No ai_assistant.py (ou onde vocÃª monta o retorno da consulta SQL), procure algo prÃ³ximo disso:

ðŸ”´ ANTES
return {
    "type": "query_result",
    "markdown": markdown_explanation,
    "explanation": explanation_text,
    "sql": sql_query,
    "data": query_result["rows"],
    "count": query_result["row_count"],
}

ðŸŸ¢ DEPOIS (retrocompatÃ­vel)
return {
    "type": "query_result",
    # texto principal da resposta em Markdown
    "content": markdown_explanation,      

    # campos antigos mantidos para nÃ£o quebrar nada do front
    "markdown": markdown_explanation,
    "explanation": explanation_text,

    "sql": sql_query,
    "data": query_result.get("rows", []),
    "count": query_result.get("row_count", 0),
}


âœ… A partir daqui, o front pode sempre confiar em data.content como texto principal em Markdown, independente do tipo.

Se vocÃª tiver outros pontos que retornam type: "query_result" (ex: quando nÃ£o hÃ¡ dados, ou quando sÃ³ retorna contagem), aplique a mesma ideia: sempre incluir content.

2. Front-end â€“ renderizar Markdown em todas respostas do bot
2.1. addChatMessage â€“ usar Markdown para mensagens do bot

Procure em static/js/app.js (ou equivalente) a funÃ§Ã£o addChatMessage.

ðŸ”´ ANTES (algo assim)
function addChatMessage(text, sender, containerId, isLoading = false) {
    const chatMessages = document.getElementById(containerId);
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('chat-message', sender);

    const contentDiv = document.createElement('div');
    contentDiv.classList.add('message-content', sender === 'user' ? 'user-message' : 'bot-message');

    if (isLoading) {
        contentDiv.innerHTML = text;
    } else {
        contentDiv.textContent = text;
    }

    messageDiv.appendChild(contentDiv);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

ðŸŸ¢ DEPOIS (Markdown para o bot)
function addChatMessage(text, sender, containerId, isLoading = false) {
    const chatMessages = document.getElementById(containerId);
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('chat-message', sender);

    const contentDiv = document.createElement('div');
    contentDiv.classList.add(
        'message-content',
        sender === 'user' ? 'user-message' : 'bot-message'
    );

    if (isLoading) {
        // mensagens de loading podem vir em HTML mesmo (spinner, etc.)
        contentDiv.innerHTML = text;
    } else if (sender === 'bot' && typeof marked !== 'undefined') {
        // aqui Ã© o pulo do gato: renderiza Markdown para o bot
        contentDiv.innerHTML = marked.parse(text);
    } else {
        // usuÃ¡rio continua como texto puro
        contentDiv.textContent = text;
    }

    messageDiv.appendChild(contentDiv);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}


âœ… Isso faz com que qualquer type: "text" e tambÃ©m type: "error" (que usam addChatMessage) fiquem bonitos com Markdown.

2.2. displayQueryResult â€“ usar content + Markdown

Agora vamos alinhar o comportamento de query_result com o resto do chat.

Procure a funÃ§Ã£o displayQueryResult(data, containerId).

ðŸ”´ ANTES (versÃ£o comum)

Vai estar mais ou menos assim:

function displayQueryResult(data, containerId) {
    const chatMessages = document.getElementById(containerId);
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('chat-message', 'bot');

    const contentDiv = document.createElement('div');
    contentDiv.classList.add('message-content', 'bot-message');

    const explanationText = data.markdown || data.explanation || 'Consulta executada.';
    const safeExplanation = escapeHtml(explanationText);
    let html = `<p><strong>${safeExplanation}</strong></p>`;

    // ... monta tabela, sql, etc ...

    contentDiv.innerHTML = html;
    messageDiv.appendChild(contentDiv);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

ðŸŸ¢ DEPOIS â€“ usando content + marked
function displayQueryResult(data, containerId) {
    const chatMessages = document.getElementById(containerId);
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('chat-message', 'bot');

    const contentDiv = document.createElement('div');
    contentDiv.classList.add('message-content', 'bot-message');

    // 1) Texto principal em Markdown
    const explanationText =
        data.content ||
        data.markdown ||
        data.explanation ||
        'Consulta executada.';

    let explanationHtml;
    if (typeof marked !== 'undefined') {
        explanationHtml = marked.parse(explanationText);
    } else {
        // fallback seguro, sem markdown
        explanationHtml = `<p>${escapeHtml(explanationText)}</p>`;
    }

    contentDiv.innerHTML = explanationHtml;

    // 2) Tabela com os dados, se existir
    if (Array.isArray(data.data) && data.data.length > 0) {
        const table = document.createElement('table');
        table.classList.add('query-result-table');

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');

        // cabeÃ§alho
        Object.keys(data.data[0]).forEach((key) => {
            const th = document.createElement('th');
            th.textContent = key;
            headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');

        // linhas
        data.data.forEach((row) => {
            const tr = document.createElement('tr');
            Object.keys(row).forEach((key) => {
                const td = document.createElement('td');
                td.textContent = row[key];
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        contentDiv.appendChild(table);
    }

    // 3) SQL opcional
    if (data.sql) {
        const sqlBlock = document.createElement('pre');
        sqlBlock.classList.add('sql-query');
        sqlBlock.textContent = data.sql;
        contentDiv.appendChild(sqlBlock);
    }

    messageDiv.appendChild(contentDiv);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}


âœ… Agora query_result tambÃ©m fica com a explicaÃ§Ã£o em Markdown, igual ao rag_response.

3. Opcional â€“ pequeno ajuste de prompt

Como vocÃª vai passar a renderizar Markdown inclusive nas respostas simples, dÃ¡ pra reforÃ§ar levemente no SYSTEM_PROMPT algo assim (se ainda nÃ£o estiver):

Todas as suas respostas para o usuÃ¡rio final devem ser em portuguÃªs (Brasil) e podem usar Markdown (tÃ­tulos, listas, negrito, tabelas) para ficar mais legÃ­veis. O front-end do sistema jÃ¡ renderiza Markdown corretamente.


Se jÃ¡ tiver algo parecido, pode manter â€” a diferenÃ§a Ã© que agora isso Ã© verdade na prÃ¡tica tambÃ©m pro type: "text" e query_result.